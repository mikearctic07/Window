/*
 * functions.c
 *
 *  Created on: 1 nov. 2018
 *      Author: migue
 */
/*
/* ******************************************************************************
 * Includes
****************************************************************************** */
#include "S32K144.h" /* include peripheral declarations S32K144 */
#include "s32_core_cm4.h"
#include "header.h"

#define PTD0 0
#define PTD15 15
#define PTD16 16
#define PTC12 12
#define PTC13 13
#define PTC8 8
#define OUTPUT_LEDS 0xF3F
#define FIRST_5_BITS 0x3F
#define FIRST_10_BITS 0x3FF
#define GPIO_ACTIVE 0x00000100

__IO uint32_t InterruptRegister;
__IO uint32_t CurrentRegister;
__IO uint32_t IteratorPinsB;
__IO uint32_t AntiPinch;


/*******************************************************************************
Function: SOSC_init_8MHz
Notes   : Set up the 8MHz clk
        :
        :
*******************************************************************************/
void SOSC_init_8MHz(void)
{
 SCG->SOSCDIV=0x00000101; /* SOSCDIV1 & SOSCDIV2 =1: divide by 1 */
 SCG->SOSCCFG=0x00000024; /* Range=2: Medium freq (SOSC between 1MHz-8MHz)*/
 while(SCG->SOSCCSR & SCG_SOSCCSR_LK_MASK); /* Ensure SOSCCSR unlocked */
 SCG->SOSCCSR=0x00000001;
 while(!(SCG->SOSCCSR & SCG_SOSCCSR_SOSCVLD_MASK)); /* Wait for sys OSC clk valid */
}
/*******************************************************************************
Function: SPLL_init_160MHz
Notes   : Set up the 160MHz clk
        :
        :
*******************************************************************************/


void SPLL_init_160MHz(void)
{
 while(SCG->SPLLCSR & SCG_SPLLCSR_LK_MASK); /* Ensure SPLLCSR unlocked */
 SCG->SPLLCSR = 0x00000000; /* SPLLEN=0: SPLL is disabled (default) */
 SCG->SPLLDIV = 0x00000302; /* SPLLDIV1 divide by 2; SPLLDIV2 divide by 4 */
 SCG->SPLLCFG = 0x00180000; /* PREDIV=0: Divide SOSC_CLK by 0+1=1 */
 while(SCG->SPLLCSR & SCG_SPLLCSR_LK_MASK); /* Ensure SPLLCSR unlocked */
 SCG->SPLLCSR = 0x00000001; /* LK=0: SPLLCSR can be written */
 while(!(SCG->SPLLCSR & SCG_SPLLCSR_SPLLVLD_MASK)); /* Wait for SPLL valid */

}


/*******************************************************************************
Function: clock_setup_80MHz
Notes   : Set up the 80MHz clock
        :
        :
*******************************************************************************/
void clock_setup_80MHz(void) /* Change to normal RUN mode with 8MHz SOSC, 80 MHz PLL*/
{

 SCG->RCCR=SCG_RCCR_SCS(6) /* PLL as clock source*/
 |SCG_RCCR_DIVCORE(0b01) /* DIVCORE=1, div. by 2: Core clock = 160/2 MHz = 80 MHz*/
 |SCG_RCCR_DIVBUS(0b01) /* DIVBUS=1, div. by 2: bus clock = 40 MHz*/
 |SCG_RCCR_DIVSLOW(0b10); /* DIVSLOW=2, div. by 3: SCG slow, flash clock= 26 2/3 MHz*/
 while (((SCG->CSR & SCG_CSR_SCS_MASK) >> SCG_CSR_SCS_SHIFT ) != 6) {}
}


/*******************************************************************************
Function: WDOG_disable
Notes   : Function to disable the watch dog timer
        :
        :
*******************************************************************************/
void WDOG_disable (void)
  {
	WDOG->CNT=0xD928C520; /*Unlock Watchdog*/
	WDOG->TOVAL=0x0000FFFF; /*Maximum timeout value*/
	WDOG->CS = 0x00002100;  /*Disable Watchdog*/
  }

/*******************************************************************************
Function: LPIT0_Ch0_IRQHandler
Notes   : Handler function for LPIT0 timer channel Interrupt
        : Timer with milliseconds option as a parameter
        :
*******************************************************************************/
void LPIT0_Ch0_IRQHandler (__IO uint32_t MILIS)
  {
	PCC->PCCn[PCC_LPIT_INDEX] = PCC_PCCn_PCS(6); /*Clock Src = 6 (SPLL2_DIV_CLK)*/
	PCC->PCCn[PCC_LPIT_INDEX] |=PCC_PCCn_CGC_MASK; /*Enable clk to LPIT0 regs*/
	LPIT0->MCR=0x00000001; /* Enables the module*/
	LPIT0->MIER =0x0000001; /* Enables the Interrupt for LPIT0*/
	LPIT0->TMR[0].TVAL = MILIS*40000; /*Channel 0 Timeout period: 40 M clocks*/
	LPIT0->TMR[0].TCTRL = 0x00000001; /*T_EN=1  : Timer channel is enabled*/
	while(0 == (LPIT0->MSR & LPIT_MSR_TIF0_MASK)); /*Waits until the flag of LPIT is asserted*/
	LPIT0->MSR |= LPIT_MSR_TIF0_MASK; /* Clears the LPIT0 interrupt Flag*/
	LPIT0->TMR[0].TCTRL = 0x00000000;/*T_EN=0  : Timer channel is disabled*/
  }


/*******************************************************************************
Function: PORTC_IRQHandler
Notes   : Handler function for Port C interrupts
        : Controls if the LED bar has to go one bit UP or DOWN
        : Checks for the current Interrupt to be executed
*******************************************************************************/
void PORTC_IRQHandler(void)
{
    __IO uint32_t counter=0; /* counter variable is initialized 0*/
	  InterruptRegister=PORTC->ISFR;  /*ISF register is stored in global variable*/
	  if(InterruptRegister == 0x100) /* Checks for interrupt generated by the AntiPinch Button*/
	  	   {
	  		   while((CurrentRegister>0)) /*while the LED bar has leds "ON", DownTransition will turn them off*/
	  		   	{
	  		   		DownTransition(counter);
	  		   		counter++;
	  		   	}
	  		    LPIT0_Ch0_IRQHandler (5000);  /*LPIT0 is initialized with timeout value = 5000 milliseconds (5 seconds)*/
	  		   	PORTC->PCR[8] |= (1<<24);     /*LPIT0 ISF Flag is cleared*/
	  	   }
	  else if(InterruptRegister==0x00001000)  /*Checks if the interrupt is generated by SW2 (PTC12)*/
	   {
		   PORTC->PCR[12] |= (1 << 24);       /*Clears flag on bit [24] of PCR register of pin 12 (SW2)*/
		   while((PTC->PDIR & (1<<PTC12)) && (PORTC->ISFR ==0 )) /*Checks if the SW2 is being pressed and the ISFR register is 0 (empty)*/
		   {
			   UpTransition(counter);		  /*LEDS will be turned on every 400 milliseconds while the SW2 is pressed*/
			   counter++;

		   }
		   if((counter<50) && (counter>1))    /*if pressed time is more than 10mS and less than 500mS LEDs will turn on Automatically*/
		   {								  /*leds will turn on Automatically*/
			   while((CurrentRegister<0x3FF) && (PORTC->ISFR ==0 ) && (PORTA->ISFR ==0 ))  /*Checks if Antipinch flag has not been raised*/
			   {
				   UpTransition(counter); /*Until all LED's are ON, UpTransition will turn them on one by one*/
				   counter++;
			   }
			}

	   }
	   else								       /*Checks for pin 13 on Port C has generated the interrupt*/
	   {
		   PORTC->PCR[13] |= (1 << 24);        /*Clears PTC13 ISFR flag*/
		   while((PTC->PDIR & (1<<PTC13)))     /*checks if pin13 Port C (SW3) is being pressed*/
			{
				DownTransition(counter);       /*LEDS's are being turned off one by one*/
				counter++;
			}
			if((counter<50) && (counter>1))
			{
				while((CurrentRegister>0) && (PORTC->ISFR ==0 )) /*if pressed time exceed 500mS and less than 10mS*/
				{												 /*LEDS are turned on Automatically*/
					DownTransition(counter);
					counter++;
				}
			}

	   }


  }



/*******************************************************************************
Function: PORTA_IRQHandler
Notes   : Handler function for PORT A Interrupts
        : AntiPinch function implemented
        : External Push Button (Port A: pin 8)
*******************************************************************************/
void PORTA_IRQHandler(void)
{
	__IO uint32_t counter=0;
	AntiPinch=1;				/*AntiPinch Flag for Interrupt is initialized 1 when entering to Handler function*/

	while((CurrentRegister>0)) /*if not all LED's are turned off, "WHILE" cycle will goes on*/
	{
		DownTransition(counter); /*LEDs are turned off Automatically*/
		counter++;
	}
	PORTA->PCR[12] |= (1<<24);   /*ISF Flag on Port A: pin 12 is being cleared*/

}


/*******************************************************************************
Function: RegisterUp
Notes   : Checks if the current register has to be updated (if one bit has to be set for Up Movement)
        :
        :
*******************************************************************************/
void RegisterUp(__IO uint32_t CurrentRegisterUp)
{
    __IO uint32_t RealBits;               /*this variable will store new value for the LED bar*/
                                          /*In order to not use PB6 and PB7*/
    if(CurrentRegisterUp>FIRST_5_BITS)    /*Checks if bit 6 or higher has to be set, shifts 2 bits and add 3 in order to use only*/
    {								      /*bits [0-5] and [8-11] */
    	RealBits=(CurrentRegisterUp<<2)+3;
    	RealBits=RealBits&OUTPUT_LEDS;
    }
    else
    {
    	RealBits=CurrentRegisterUp;       /*if bit 6 must not be set yet, the current register remains the same*/
    }

    PTB-> PCOR |= RealBits;               /*Clear LED's on Current register (LEDS on)*/
}

/*******************************************************************************
Function:
Notes   : Checks if the current register has to be updated (if one bit has to be cleared for Down Movement)
        :
        :
*******************************************************************************/
void RegisterDown(__IO uint32_t CurrentRegisterDown)
{
	__IO uint32_t RealBits;
	if(CurrentRegisterDown>FIRST_5_BITS)       /*Checks if bit 6 or higher has to be clear, shifts-left 2 bits and add 3 in order to use only*/
		{								       /*bits [0-5] and [8-11] */
			RealBits=(CurrentRegisterDown<<2)+3;
			RealBits=RealBits&OUTPUT_LEDS;
		}
	else
		{
			RealBits=CurrentRegisterDown;      /*if bit 6 must not be cleared yet, the current register remains the same*/
		}

	PTB-> PSOR = ~RealBits;                    /*Set LEDs on Current register (LEDS OFF)*/
}

/*******************************************************************************
Function: UpMovement
Notes   : Generates the current register of LED bar if one bit has to be incremented
        :
        :
*******************************************************************************/
void UpMovement(void)
{
	CurrentRegister=(CurrentRegister<<1)+1;        /*adds the next bit to be turned on*/
	CurrentRegister=CurrentRegister&FIRST_10_BITS; /*Current register is prepared with the MASK*/
	RegisterUp(CurrentRegister);                   /*New current register is created while avoiding bits [0-5] and [8-11] */
}


/*******************************************************************************
Function: DownMovement
Notes   : Generates the current register of LED bar if one bit has to be decremented
        :
        :
*******************************************************************************/
void DownMovement(void)
{
	CurrentRegister=CurrentRegister>>1;            /*takes the next bit to be turned off*/
	RegisterDown(CurrentRegister);                 /*New current register is created while avoiding bits [0-5] and [8-11] */
}

/*******************************************************************************
Function: UpTransition
Notes   : Generates  a valid "Up" transition (more than 10 mS and increments every 400 mS)
        :
        :
*******************************************************************************/
void UpTransition(__IO uint32_t counter)
{
	PTD->PTOR |=(1<<16);      /*Toggles Green LED while the LED bar increments*/
    LPIT0_Ch0_IRQHandler(10); /*LPIT0 timer is initialized with timeout = 10ms*/
    PTD->PTOR |=(1<<16);      /*Toggles Green LED while the LED bar increments*/

    if ((counter>=1) && (counter%40 ==0)) /* if 40 X 10ms = 400ms, checks for valid time and increments one led every 400ms*/
    {
 	   UpMovement();
    }
}



/*******************************************************************************
Function: DownTransition
Notes   : Generates  a valid "Down" transition (more than 10 mS and increments every 400 mS)
        :
        :
*******************************************************************************/
void DownTransition(__IO uint32_t counter)
{
	PTD->PTOR |=(1<<0);        /*Toggles Blue LED while the LED bar increments*/
    LPIT0_Ch0_IRQHandler(10);  /*LPIT0 timer is initialized with timeout = 10ms*/
    PTD->PTOR |=(1<<0);        /*Toggles Blue LED while the LED bar increments*/

    if ((counter>=1) && (counter%40 ==0)) /* if 40 X 10ms = 400ms, checks for valid time and decrements one led every 400ms*/
    {
 	   DownMovement();
    }
}


/*******************************************************************************
Function: init_GPIO
Notes   : Initializes clks for Ports: A,B,C and D, GPIOS and Interrupt functionalities
        : for each pin selected as Input or Output
        :
*******************************************************************************/
void init_GPIO(void)
{
	PCC-> PCCn[PCC_PORTC_INDEX] = PCC_PCCn_CGC_MASK; /*Enable clock to PORT C*/
	PCC-> PCCn[PCC_PORTD_INDEX] = PCC_PCCn_CGC_MASK; /*Enable clock to PORT D*/
	PCC-> PCCn[PCC_PORTB_INDEX] = PCC_PCCn_CGC_MASK; /*Enable clock to PORT B*/
	PCC-> PCCn[PCC_PORTA_INDEX] = PCC_PCCn_CGC_MASK; /*Enable clock to PORT A*/

	PTC->PDDR &= ~(1<<PTC12);     /*Port C12: Data Direction = input (default) */
	PORTC->PCR[12] = 0x00098110;  /*Port C12: MUX=GPIO, ISF flag on rising-edge*/

	PTC->PDDR &= ~(1<<PTC13);     /*Port C12: Data Direction = input */
	PORTC->PCR[13] = 0x00098110;  /*Port C13: MUX=GPIO, ISF flag on rising-edge*/

	/*PTB6 and PTB7 are not used because they're reserved for external oscillator*/
	PTB->PDDR |= OUTPUT_LEDS; /*Port D: Mask of bits configured as outputs*/
	for(IteratorPinsB=0;IteratorPinsB<=5;IteratorPinsB++)
	{
		PORTB->PCR[IteratorPinsB] = GPIO_ACTIVE; /*Port B pins 0 to 5, MUX = GPIO*/
	}

	for(IteratorPinsB=8;IteratorPinsB<=11;IteratorPinsB++)
	{
		PORTB->PCR[IteratorPinsB] = GPIO_ACTIVE;  /*Port B pins 0 to 5, MUX = GPIO*/
	}

	PTD->PDDR |= 1<<PTD0;        /*Port D0: Data Direction= output*/
	PORTD->PCR[0] = GPIO_ACTIVE; /*Port D0: MUX = GPIO*/

	PTD->PDDR |= 1<<PTD15;       /*Port D15: Data Direction= output*/
	PORTD->PCR[15] = GPIO_ACTIVE;/*Port D15: MUX = GPIO*/

	PTD->PDDR |= 1<<PTD16;       /*Port D16: Data Direction= output*/
	PORTD->PCR[16] = GPIO_ACTIVE;/*Port D16: MUX = GPIO*/

	PTC->PDDR &= ~(1<<PTC8);     /*Port C8: Data Direction = input*/
	PORTC->PCR[8] = 0x00090112;  /*Port C8: MUX= GPIO, ISF on rising edge*/
}
